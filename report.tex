\documentclass{article}

\usepackage[a4paper, margin=3cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amsfonts, enumitem, tikz, parskip, url}

\newcommand{\hh}{$\mathcal{H}$}
\newcommand{\hash}[2][]{\mathcal{H}^{#1}(#2)}
\newcommand{\binwds}[1]{\{0, 1\}^{#1}}

\title{Esquemas de assinatura digital pós-quânticos \\ baseados em AES}
\author{Gustavo Zambonin \\ \texttt{gustavo.zambonin@grad.ufsc.br} \and Marcello da Silva Klingelfus Junior \\ \texttt{marcello.klingelfus@grad.ufsc.br}}
\date{}

\begin{document}

\maketitle

\section{Introdução}

A aplicação de protocolos criptográficos é essencial no contexto da validação e
proteção de quaisquer comunicações realizadas por um conjunto de entidades,
sejam estas dispositivos eletrônicos ou indivíduos, em virtude da possível
criticalidade e sensibilidade atribuídas aos dados transmitidos. Esquemas de
assinatura digital são comumente utilizados para assegurar este processo de
maneira formal \cite{Goldreich:2004:FCV:975541}, através da autenticidade e
não-repúdio do remetente e certeza da integridade dos dados, a fim de
traduzir o resguardo provido por uma assinatura de próprio punho no mundo real.

Na prática, a maior parte destes esquemas utilizam como alicerce algorítmico
criptossistemas assimétricos baseados em problemas `'difíceis`' da teoria
dos números, como a fatoração de inteiros ou resolução do logaritmo discreto,
ambos para números grandes. Este fato provê a segurança necessária para os
esquemas em computadores clássicos (eletrônicos), por conta da inexistência de
algoritmos que resolvem estes problemas em tempo polinomial, até o momento.
Entretanto, em computadores quânticos, algoritmos dessa forma já existem - em
especial, o algoritmo de Shor \cite{Shor:1997:PAP:264393.264406} - efetivamente
tornando estes esquemas clássicos inseguros neste novo contexto.

Para combater esta situação, a criptografia pós-quântica encarrega-se de buscar
algoritmos criptográficos cuja segurança é considerada suficiente mesmo
utilizando-se de um computador quântico e ataques especializados, como o
algoritmo de Grover \cite{Grover:1996:FQM:237814.237866}. Esta área conta com
diversas abordagens diferentes: a criptografia baseada em reticulados,
polinômios multivariados sobre um corpo finito, códigos de correção de erros,
morfismos entre curvas elípticas supersingulares, criptossistemas simétricos.
e funções de resumo criptográfico. Em especial, é possível mesclar as duas
últimas opções a fim de aproveitar, respectivamente, o desempenho e a
simplicidade destas, bem como demonstrar a versatilidade garantida pelas
diferentes funções que podem ser utilizadas para a criação destes esquemas.

\section{Funções de resumo criptográfico}

Uma função de resumo \hh{} mapeia valores deterministicamente entre dois
conjuntos. O domínio pode ter tamanho infinito, e neste caso a função pode ser
chamada de função de compressão; a imagem deve ser estritamente menor do que o
domínio e finita, e elementos deste conjunto são chamados de resumos. É
desejável para \hh{} que estes mapeamentos ocorram de tal maneira que não
ocorra uma relação aparente entre entradas e saídas da função. Funções de
resumo adicionadas de propriedades que tornam-as adequadas para utilização no
contexto de segurança da informação são chamadas de funções de resumo
criptográfico, e possibilitam a certeza da integridade de dados, mesmo que
armazenados em um dispositivo inseguro.

Tome $X : \binwds{*}$ e $Y : \binwds{n}$, $n \in \mathbb{N}$. Então,
$\mathcal{H} : X \longrightarrow Y$. De acordo com
\cite{stinson2005cryptography}, para que qualquer \hh{} seja considerada
criptográfica, deve ser difícil resolver os três problemas listados abaixo.
É importante notar que um problema é considerado `'difícil`', ou
computacionalmente impraticável, quando o tempo ou recursos gastos para esta
computação excedem a validade ou utilidade da informação desejada.

\begin{enumerate}[label=\roman*.]

  \item Fornecido um resumo $h \in Y$, achar a mensagem original $m \in X$ que
    gerou $h$ através de $\hash{m} = h$; \hh{} é considerada resistente à
    pré-imagem (\textsc{Pre}) se isto não pode ser resolvido de maneira
    eficiente.

  \item Fornecida uma mensagem $m_0 \in X$, achar uma mensagem $m_1 \in X$ tal
    que $m_0 \neq m_1$ e $\hash{m_0} = \hash{m_1}$. \hh{} é considerada
    resistente à segunda pré-imagem (\textsc{Sec}) se isto não pode ser
    resolvido de maneira eficiente.

  \item Para quaisquer duas mensagens $m_0, \; m_1 \in X$ e $m_0 \neq m_1$,
    $\hash{m_0} = \hash{m_1}$. \hh{} é considerada resistente à colisões
    (\textsc{Col}) se isto não pode ser resolvido de maneira eficiente.

\end{enumerate}

\section{Criptografia simétrica}

Algoritmos criptográficos que utilizam a mesma chave para criptografar o
texto plano e descriptografar o texto correspondente cifrado são classificados
como algoritmos de criptografia simétrica. A chave representa um segredo
compartilhado entre entidades em uma comunicação segura. Porém, a necessidade
de um canal seguro para o estabelecimento desta chave apresenta-se como uma
desvantagem deste tipo de criptografia. Geralmente, cifras de bloco (DES, AES)
ou de fluxo (RC4, Salsa20) são a base para estes algoritmos. Utilizando estas
como alicerce, é possível construir funções de resumo criptográfico: por
exemplo, a construção Merkle-Damgård, base para as funções MD5, SHA1 e SHA2,
utiliza uma função de compressão única, obtida a partir de uma cifra de bloco.

\subsection{AES --- \emph{Advanced Encryption Standard}}

O AES é uma cifra de blocos que opera, a partir de uma chave $K$,
sobre uma matriz de estado $A$ de dimensões $4 \times 4$, onde $A_{i,j} \in \mathbb{F}_{2^{8}}$\footnote{Definido pelo polinômio irredutível $m(x) = x^{8} + x^{4} + x^{3} + x + 1$. Adições e multiplicações em corpos da forma $\mathbb{F}_{2^n}$ são, respectivamente, representadas por operações \texttt{AND} e \texttt{XOR}, e coeficientes de polinômios podem ser apenas $0$ ou $1$, tornando esta estrutura convidativa para operações computacionais.}, $0 \leq i, j < 3$. Seu funcionamento é denominado
iterativo, consistindo na aplicação de uma sequência de quatro operações (\textsc{SubBytes}, \textsc{ShiftRows}, \textsc{MixColumns} e \textsc{AddRoundKey}) sobre $A$. A quantidade destas aplicações, denominadas rodadas ($n_r$), depende diretamente do tamanho da chave, e.g. para uma chave de 128 bits, $n_r = 10$.

As operações realizadas em cada rodada são denominadas . Note que existe uma rodada adicional introdutória
composta apenas de \textsc{AddRoundKey}, para que o estado inicial seja modificado. Ademais, \textsc{MixColumns} é ignorado na última rodada, a fim de habilitar a reversibilidade da cifra.
As operações são descritas em detalhe abaixo, juntamente com a rotina de expansão de chave.

\begin{enumerate}

    \item[\textsc{SubBytes}] Realiza-se a substituição de cada elemento da matriz de estado
        pelo seu valor correspondente em uma \emph{substitution-box} (\emph{S-box}), onde os quatro bits mais à esquerda e direita, respectivamente, representam a linha e a coluna do elemento na \emph{S-box}.
    
    \item[\textsc{ShiftRows}] Assumindo que a indexação de linhas da matriz de estado começa
        em $0$, cada linha da matriz é deslocada circularmente à esquerda pelo valor de seu
        índice.
    
    \item[\textsc{MixColumns}] Cada coluna da matriz de estado é multiplicada pelo polinômio
        $c = 03 \cdot s^{3} + 01 \cdot s^{2} + 01 \cdot s + 02$, módulo $x^{4} + 1$.
        
    \item[\textsc{AddRoundKey}] A operação ``ou exclusivo'' bit a bit é aplicada entre a
        matriz de estado e o bloco da chave referente à rodada.

\end{enumerate}

A expansão de chaves consiste de um procedimento que recebe a chave inicial
do algoritmo, de tamanho $n = \{128, 192, 256\}$, e retorna um conjunto
de $4(n_r + 1)$ palavras de 32 bits, denominado de chave expandida.
Cada conjunto de 4 palavras sucessivas é utilizado em uma rodada do algoritmo.
As primeiras $n / 32$ entradas deste conjunto são populadas pela divisão da
chave inicial. Todas as palavras posteriores consecutivas são construídas da
seguinte maneira: se o índice da palavra no conjunto divide $n$



    % \item[\textsc{KeyExpansion}] Derivar as chaves de cada rodada a partir da chave inicial (KeyExpansions): O algoritmo é copia a chave inicial para as primeiras posições da chave expandida. Cada 4bytes inseridos dependem dos 4bytes imediatamente anterior e dos bytes inseridos 4 posições atrás. Caso a posição/4 = i e $i \pmod{n} != 0$, onde n = 4 para k = 16bytes,6 para k = 24bytes e 8 para k = 32bytes), os 8bytes são gerados com um simples XOR entre as os bytes da qual eles dependem, caso contrario eles são gerados através das seguintes operações: RotWord-> SubWord -> Rcon. 
    % \begin{enumerate}
    %     \item A subfunção RotWord a qual faz uma troca de bytes na, onde o byte da primeira posição é colocado na última posição e os bytes das outras posições são deslocados à esquerda. 
    %     \item A subfunção SubWord substitui cada byte pelo valor respectivo na caixa S-Box. 
    %     \item Rcon é um byte constante que tem os três bits mais à direita com valor zerado e o byte mais à esquerda é definido pela multiplicação no corpo finito.
    % \end{enumerate} 


% \begin{itemize}

% \item Derivar as chaves de cada rodada a partir da chave inicial (KeyExpansions): O algoritmo é copia a chave inicial para as primeiras posições da chave expandida. Cada 4bytes inseridos dependem dos 4bytes imediatamente anterior e dos bytes inseridos 4 posições atrás. Caso a posição/4 = i e $i \pmod{n} != 0$, onde n = 4 para k = 16bytes,6 para k = 24bytes e 8 para k = 32bytes), os 8bytes são gerados com um simples XOR entre as os bytes da qual eles dependem, caso contrario eles são gerados através das seguintes operações: RotWord-> SubWord -> Rcon. 
%     \begin{enumerate}
%     \item A subfunção RotWord a qual faz uma troca de bytes na, onde o byte da primeira posição é colocado na última posição e os bytes das outras posições são deslocados à esquerda. 
%     \item A subfunção SubWord substitui cada byte pelo valor respectivo na caixa S-Box. 
%     \item Rcon é um byte constante que tem os três bits mais à direita com valor zerado e o byte mais à esquerda é definido pela multiplicação no corpo finito.
%     \end{enumerate} 

% \item Na primeira rodada temos o estado definido como a mensagem dividida em blocos de 16bytes, e é feito um XOR bit a bit entre os bytes do estado e a chave da primeira rodada(AddRoundKey).
%     \begin{enumerate}
%         \item $estado[0] = mensagem$
%         \item $estado[1] = estado[0] XOR ChaveRodada[0]$
%     \end{enumerate}

% \item Nas rodadas consequentes até a penultima é feito uma troca de cada byte do estado atual pelo valor correspondente nas caixa S, em seguida é feita um deslocamento circular, no qual o estado é escrito em forma matricial e as suas linhas são deslocadas de forma circular em 0,1,2 ou 3 para a esquerda, então é feito o embaralhamento das colunas do estado em forma de matriz, cada byte da coluna é mapeado para um novo valor o qual é obtido atrvés de uma função onde ocorre uma multiplicação entre state e uma matriz específica, cada elemento do produto das matrizes é a soma dos produtos dos elementos de uma linha e uma coluna.


% KeyExpansions—round keys are derived from the cipher key using Rijndael's key schedule. AES requires a separate 128-bit round key block for each round plus one more.

% InitialRound
% AddRoundKey—each byte of the state is combined with a block of the round key using bitwise xor.

% Rounds
% SubBytes—a non-linear substitution step where each byte is replaced with another according to a lookup table.
% ShiftRows—a transposition step where the last three rows of the state are shifted cyclically a certain number of steps.
% MixColumns—a mixing operation which operates on the columns of the state, combining the four bytes in each column.
% AddRoundKey

% Final Round (no MixColumns)
% SubBytes
% ShiftRows
% AddRoundKey.

% \end{itemize}
% -O processo de cifra é feito, ordenadamente, através de: 
% XOR bit a bit entre a chave e a mensagem
% Substituição de sucessões (Nibble Substituition) com caixas S
% Deslocamento Circular
% Embaralhamento das Colunas
% XOR bit a bit entre a chave expandida e a mensagem
% Substituição de sucessões com caixas S
% Deslocamento Circular
% XOR bit a bit entre a chave expandida e a mensagem


\section*{Criptografia assimétrica}

\section*{Esquemas de assinatura digital}

\section*{O esquema Winternitz}
% * como plugar o AES nele
% * esquemas posteriores

\bibliographystyle{alpha}
\bibliography{report} 

\end{document}