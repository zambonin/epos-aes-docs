\documentclass{article}

\usepackage[a4paper, margin=3cm]{geometry}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[portuguese, onelanguage]{algorithm2e}
\usepackage{amsmath, amsfonts, enumitem, tikz, parskip, url}

\newcommand{\hh}{$\mathcal{H}$}
\newcommand{\pk}{$\mathcal{P}_k$}
\newcommand{\sk}{$\mathcal{S}_k$}
\newcommand{\hash}[2][]{\mathcal{H}^{#1}(#2)}
\newcommand{\binwds}[1]{\{0, 1\}^{#1}}
\newcommand{\concat}{\, \vert \vert \,}

\renewcommand*{\thefootnote}{(\arabic{footnote})}

\title{Esquemas de assinatura digital pós-quânticos \\ baseados em AES\footnote{Texto parcialmente reproduzido do Trabalho de Conclusão de Curso do primeiro autor.}}
\author{Gustavo Zambonin \\ \texttt{gustavo.zambonin@grad.ufsc.br} \and Marcello da Silva Klingelfus Junior \\ \texttt{marcello.klingelfus@grad.ufsc.br}}
\date{}

\begin{document}

\maketitle

\section{Introdução}

A aplicação de protocolos criptográficos é essencial no contexto da validação e
proteção de quaisquer comunicações realizadas por um conjunto de entidades,
sejam estas dispositivos eletrônicos ou indivíduos, em virtude da possível
criticalidade e sensibilidade atribuídas aos dados transmitidos. Esquemas de
assinatura digital são comumente utilizados para assegurar este processo de
maneira formal \cite{Goldreich:2004:FCV:975541}, através da autenticidade e
não-repúdio do remetente e certeza da integridade dos dados, a fim de
traduzir o resguardo provido por uma assinatura de próprio punho no mundo real.

Na prática, a maior parte destes esquemas utilizam como alicerce algorítmico
criptossistemas assimétricos baseados em problemas `'difíceis`' da teoria
dos números, como a fatoração de inteiros ou resolução do logaritmo discreto,
ambos para números grandes. Este fato provê a segurança necessária para os
esquemas em computadores clássicos (eletrônicos), por conta da inexistência de
algoritmos que resolvem estes problemas em tempo polinomial, até o momento.
Entretanto, em computadores quânticos, algoritmos dessa forma já existem - em
especial, o algoritmo de Shor \cite{Shor:1997:PAP:264393.264406} - efetivamente
tornando estes esquemas clássicos inseguros neste novo contexto.

Para combater esta situação, a criptografia pós-quântica encarrega-se de buscar
algoritmos criptográficos cuja segurança é considerada suficiente mesmo
utilizando-se de um computador quântico e ataques especializados, como o
algoritmo de Grover \cite{Grover:1996:FQM:237814.237866}. Esta área conta com
diversas abordagens diferentes: a criptografia baseada em reticulados,
polinômios multivariados sobre um corpo finito, códigos de correção de erros,
morfismos entre curvas elípticas supersingulares, criptossistemas simétricos.
e funções de resumo criptográfico. Em especial, é possível mesclar as duas
últimas opções a fim de aproveitar, respectivamente, o desempenho e a
simplicidade destas, bem como demonstrar a versatilidade garantida pelas
diferentes funções que podem ser utilizadas para a criação destes esquemas.

\section{Funções de resumo criptográfico}

Uma função de resumo \hh{} mapeia valores deterministicamente entre dois
conjuntos. O domínio pode ter tamanho infinito, e neste caso a função pode ser
chamada de função de compressão; a imagem deve ser estritamente menor do que o
domínio e finita, e elementos deste conjunto são chamados de resumos. É
desejável para \hh{} que estes mapeamentos ocorram de tal maneira que não
ocorra uma relação aparente entre entradas e saídas da função. Funções de
resumo adicionadas de propriedades que tornam-as adequadas para utilização no
contexto de segurança da informação são chamadas de funções de resumo
criptográfico, e possibilitam a certeza da integridade de dados, mesmo que
armazenados em um dispositivo inseguro.

Tome $X : \binwds{*}$ e $Y : \binwds{n}$, $n \in \mathbb{N}$. Então,
$\mathcal{H} : X \longrightarrow Y$. De acordo com
\cite{stinson2005cryptography}, para que qualquer \hh{} seja considerada
criptográfica, deve ser difícil resolver os três problemas listados abaixo.
É importante notar que um problema é considerado `'difícil`', ou
computacionalmente impraticável, quando o tempo ou recursos gastos para esta
computação excedem a validade ou utilidade da informação desejada.

\begin{enumerate}[label=\roman*.]

  \item Fornecido um resumo $h \in Y$, achar a mensagem original $m \in X$ que
    gerou $h$ através de $\hash{m} = h$; \hh{} é considerada resistente à
    pré-imagem (\textsc{Pre}) se isto não pode ser resolvido de maneira
    eficiente.

  \item Fornecida uma mensagem $m_0 \in X$, achar uma mensagem $m_1 \in X$ tal
    que $m_0 \neq m_1$ e $\hash{m_0} = \hash{m_1}$. \hh{} é considerada
    resistente à segunda pré-imagem (\textsc{Sec}) se isto não pode ser
    resolvido de maneira eficiente.

  \item Para quaisquer duas mensagens $m_0, \; m_1 \in X$ e $m_0 \neq m_1$,
    $\hash{m_0} = \hash{m_1}$. \hh{} é considerada resistente à colisões
    (\textsc{Col}) se isto não pode ser resolvido de maneira eficiente.

\end{enumerate}

\section{AES --- \emph{Advanced Encryption Standard}}

O AES é uma cifra de blocos que opera sobre uma matriz de estado $A$ de dimensões $4 \times 4$, onde $A_{i,j} \in \mathbb{F}_{2^{8}}$\footnote{Definido pelo polinômio irredutível $m(x) = x^{8} + x^{4} + x^{3} + x + 1$. Adições e multiplicações em corpos da forma $\mathbb{F}_{2^n}$ são, respectivamente, representadas por operações \texttt{AND} e \texttt{XOR}, e coeficientes de polinômios são palavras binárias, tornando esta estrutura convidativa para operações computacionais.}, $0 \leq i, j < 4$, a partir de uma chave $K$ de tamanho $n = \{128, 192, 256\}$. Seu funcionamento é denominado iterativo, consistindo em aplicações sequenciais de quatro operações ordenadas (\textsc{SubBytes}, \textsc{ShiftRows}, \textsc{MixColumns} e \textsc{AddRoundKey}) sobre $A$. A quantidade destas aplicações, denominadas rodadas ($n_r$), depende diretamente do tamanho da chave: $n = 128 \rightarrow n_r = 10, n = 192 \rightarrow n_r = 12, n = 256 \rightarrow n_r = 14$.

Note que existe uma rodada adicional introdutória composta apenas de \textsc{AddRoundKey},
para que o estado inicial seja modificado. Ademais, \textsc{MixColumns} é ignorado na última rodada, a fim de facilitar a reversibilidade da cifra. Uma rotina de expansão de chave (\textsc{KeyExpansion} existe para que $K$ seja propagada em todas as rodadas com valores derivados, porém distintos. Estes componentes serão descritos abaixo.

\begin{enumerate}[label=\roman*.]

    \item \textsc{SubBytes}: realiza-se a reposição de $A_{i,j}$
        pelo seu valor correspondente em uma \emph{substitution-box} (\emph{S-box}, construída a partir de uma transformação afim em $A_{i,j}^{-1}$ sobre $\mathbb{F}_2$), onde os \emph{nibbles} mais e menos significativos, respectivamente, representam a linha e a coluna do elemento na \emph{S-box}.

    \item \textsc{ShiftRows}: cada linha de $A$, $A_i$,
        é deslocada circularmente à esquerda $i$ vezes.

    \item \textsc{MixColumns}: cada coluna de $A$, $A_j$, é multiplicada pelo polinômio
        $c = 03 \cdot x^{3} + 01 \cdot x^{2} + 01 \cdot x + 02$, módulo $x^{4} + 1$, para que o resultado ainda seja um polinômio de grau máximo 3, apto a ser representado na coluna.

    \item \textsc{AddRoundKey}: a operação \texttt{XOR} bit a bit é aplicada entre $A$ e o
        bloco da chave referente à rodada.

\end{enumerate}

\textsc{KeyExpansion} consiste da criação de um conjunto de palavras $K_e$ de 32 bits.
Tome $\ell = \frac{n}{32}$, e assumindo que é necessário criar palavras suficientes para utilização em todas as rodadas do algoritmo, então $t = \ell \cdot (n_r + 1)$ e $K^e = \{k_0, \dots, k_{t - 1}\}$. Também defina $rot(x)$ como o deslocamento circular à esquerda de 8 bits da palavra $x$, e a lista de constantes $RC$ com elementos em $\mathbb{F}_{2^{8}}$ definida pela recursão $RC_0 = x^0, RC_1 = x^1, RC_j = x^{j-1} \cdot RC_{j-1}, j > 2$. Inicialmente, $\{k_0, \dots, k_{\ell - 1}\} = K$, e $\forall i \geq \ell, K^{e}_{i} = K^{e}_{i - \ell} \oplus \mathbf{k}$. A palavra $\mathbf{k}$, inicialmente com valor $K^{e}_{i - 1}$, pode ser modificada de acordo com as restrições (mutualmente exclusivas) abaixo.

\begin{itemize}
    \item $i \equiv 0 \pmod{4} \rightarrow \mathbf{k}
        = \textsc{SubBytes}(rot(K^{e}_{i - 1})) \oplus RC_{\frac{i}{\ell}}$;
    \item $\ell = 8 \land i \equiv 4 \pmod{8} \rightarrow \mathbf{k}
        = \textsc{SubBytes}(K^{e}_{i - 1})$.
\end{itemize}

Assim, uma função que criptografa uma mensagem $m$ e retorna um texto cifrado $c$ pode ser
representada pelo pseudocódigo abaixo.

\begin{algorithm}[H]
    \KwData{$m$, o texto a ser cifrado; $K$, a chave desejada}
    \KwResult{$c$, o texto cifrado resultante}

    $A \longleftarrow m$\;
    $K^{e}_{0} \dots K^{e}_{(n_r + 1) \cdot \ell}
        \longleftarrow \textsc{KeyExpansion}(K)$\;
    $A \longleftarrow \textsc{AddRoundKey}(A,
        \{K^{e}_{0}, \dots, K^{e}_{\ell - 1}\})$\;
    
    \For{$i \leftarrow 1$ \KwTo $n_r - 1$}{
        $A \longleftarrow \textsc{SubBytes}(A)$\;
        $A \longleftarrow \textsc{ShiftRows}(A)$\;
        $A \longleftarrow \textsc{MixColumns}(A)$\;
        $A \longleftarrow \textsc{AddRoundKey}(A,
            \{K^{e}_{i \cdot \ell}, \dots, K^{e}_{(i + 1) \cdot \ell - 1}\})$\;
    }
 
    $A \longleftarrow \textsc{SubBytes}(A)$\;
    $A \longleftarrow \textsc{ShiftRows}(A)$\;
    $A \longleftarrow \textsc{AddRoundKey}(A,
        \{K^{e}_{n_r \cdot \ell}, \dots, K^{e}_{(n_r + 1) \cdot \ell - 1}\})$\;

    $c \longleftarrow A$\;
\end{algorithm}

Para que a cifra seja caracterizada como simétrica, é preciso criar uma função que faça o inverso do procedimento acima. Assim, suas etapas precisam ser modificadas de acordo.

\begin{enumerate}[label=\roman*.]

    \item \textsc{InvShiftRows}: cada linha de $A$, $A_i$, é deslocada circularmente à direita $i$ vezes.

    \item \textsc{InvSubBytes}: é necessário computar a transformação afim inversa para cada elemento $A_{i,j}$, e depois calcular sua inversa multiplicativa.
    
    \item \textsc{InvMixColumns}: cada coluna de $A$, $A_j$, é multiplicada pela inversa multiplicativa $d = c^{-1}$, obtida por: $(03 \cdot x^{3} + 01 \cdot x^{2} + 01 \cdot x + 02) \cdot d \equiv 1 \pmod{x^{4} + 1}$, logo $d(x) = 0B \cdot x^{3} + OD \cdot x^{2} + 09 \cdot x + 0E$.

\end{enumerate}

Por fim, o algoritmo resultante pode ser representado pelo pseudocódigo abaixo. Note a mudança da ordem das etapas, e a utilização invertida de $K_e$.

\begin{algorithm}[H]
    \KwData{$c$, o texto cifrado; $K$, a chave desejada}
    \KwResult{$m$, o texto claro resultante}

    $A \longleftarrow c$\;
    $K^{e}_{0} \dots K^{e}_{(n_r + 1) \cdot \ell}
        \longleftarrow \textsc{KeyExpansion}(K)$\;
    $A \longleftarrow \textsc{AddRoundKey}(A,
        \{K^{e}_{n_r \cdot \ell}, \dots, K^{e}_{(n_r + 1) \cdot \ell - 1}\})$\;
    
    \For{$i \leftarrow n_r - 1$ \KwTo $1$}{
        $A \longleftarrow \textsc{InvShiftRows}(A)$\;
        $A \longleftarrow \textsc{InvSubBytes}(A)$\;
        $A \longleftarrow \textsc{AddRoundKey}(A,
            \{K^{e}_{i \cdot \ell}, \dots, K^{e}_{(i + 1) \cdot \ell - 1}\})$\;
        $A \longleftarrow \textsc{InvMixColumns}(A)$\;
    }
 
    $A \longleftarrow \textsc{InvShiftRows}(A)$\;
    $A \longleftarrow \textsc{InvSubBytes}(A)$\;
    $A \longleftarrow \textsc{AddRoundKey}(A,
        \{K^{e}_{0}, \dots, K^{e}_{\ell - 1}\})$\;

    $m \longleftarrow A$\;
\end{algorithm}

\section{Criptografia simétrica}

Algoritmos criptográficos que utilizam a mesma chave para criptografar o
texto plano e descriptografar o texto correspondente cifrado são classificados
como algoritmos de criptografia simétrica. A chave representa um segredo
compartilhado entre entidades em uma comunicação segura. Porém, a necessidade
de um canal seguro para o estabelecimento desta chave apresenta-se como uma
desvantagem deste tipo de criptografia. Geralmente, cifras de bloco (DES, AES)
ou de fluxo (RC4, Salsa20) são a base para estes algoritmos. Utilizando estas
como alicerce, é possível construir funções de resumo criptográfico: por
exemplo, a construção Merkle-Damgård, base para as funções MD5, SHA1 e SHA2,
utiliza uma função de compressão única, obtida a partir de uma cifra de bloco.

\section{Criptografia assimétrica}

Em contrapartida, a criptografia assimétrica, ou criptografia de chaves
públicas, engloba os algoritmos que utilizam um par de chaves: a chave privada
(\sk{}), conhecida apenas pela entidade que a gerou, e a chave pública (\pk{}),
distribuída livremente. Isto possibilita o uso livre de \pk{} para a
comunicação segura com o detentor da chave sem a necessidade de um canal
seguro, em virtude da construção dos algoritmos. A segurança destes depende da
``dificuldade'' computacional de determinar uma chave privada a partir da chave
pública, e também do armazenamento de \sk{} em um lugar seguro. Problemas em
teoria de números e álgebra que atualmente não admitem soluções em tempo
polinomial são comumente utilizados como base para algoritmos assimétricos.
Porém, percebe-se que, com a introdução de um computador quântico, estes
problemas podem ser resolvidos de maneira significativamente mais rápida, como
visto em~\cite{Shor:1997:PAP:264393.264406}.

\section{Esquemas de assinatura digital}

Um esquema de assinatura digital é uma construção matemática que habilita a
demonstração de certas propriedades sobre mensagens assinadas: nomeadamente,
a autenticação do remetente, onde esta entidade pode ser facilmente
identificada como a emissora da assinatura digital; a integridade da mensagem,
i.e. a certeza de que esta não foi modificada ao ser transmitida por um canal
possivelmente inseguro; e o não-repúdio do remetente, onde não é possível negar
que uma mensagem foi assinada e enviada, após este fato.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}
    \node (hm) at (-1.25, 0) {$m$};
    \node (in) at (0, -2) {$1^n$};
    \node (sk) at (0, -1) {\sk{}};
    \node (pk) at (4, -1) {\pk{}};
    \node (ds) at (2, 0)
      {\scriptsize{$m \concat \textsc{Sig}(\mathcal{S}_k, \hash{m})$}};
    \node (res) at (5.5, 0) {\scriptsize\{0, 1\}};
    \node[draw] (sig) at (0, 0) {\textsc{Sig}};
    \node[draw] (gen) at (2, -2) {\textsc{Gen}};
    \node[draw] (ver) at (4, 0) {\textsc{Ver}};
    \draw[-latex] (gen) to (1.25, -1) to (sk);
    \draw[-latex] (gen) to (2.75, -1) to (pk);
    \draw[-latex] (sk) -- (sig);
    \draw[-latex] (hm) -- (sig);
    \draw[-latex] (sig) -- (ds);
    \draw[-latex] (ds) -- (ver);
    \draw[-latex] (pk) -- (ver);
    \draw[-latex] (ver) -- (res);
    \draw[-latex] (in) -- (gen);
  \end{tikzpicture}
  \caption{Funcionamento típico de um esquema de assinatura digital.}
  \label{fig:2}
\end{figure}

Esquemas de assinatura digital são fortemente baseados em criptografia de
chaves públicas, e consistem de três algoritmos: a geração de chaves
$\textsc{Gen}(1^n)$, que gera um par de chaves aleatório $(\mathcal{P}_k,
\mathcal{S}_k)$ com parâmetro de segurança $n$; o algoritmo de assinatura
$\textsc{Sig}(\mathcal{S}_k, m)$, que produz uma assinatura $\sigma$ para uma
mensagem $m$; e o algoritmo de verificação $\textsc{Ver}(\mathcal{P}_k, m,
\sigma)$, que retorna o estado de validade da assinatura como um valor verdade
binário. De acordo com~\cite{Goldreich:2004:FCV:975541}, todas as assinaturas
geradas por \textsc{Sig} devem ser verificáveis por \textsc{Ver} utilizando
todas as chaves geradas por \textsc{Gen}. Formalmente, $\forall (p, s) \in
\textsc{Gen}^{\rightarrow}(1^n)$ e $\forall w \in \{0, 1\}^{*}$,
\begin{equation}
    \text{Pr}[\textsc{Ver}(p, w, \textsc{Sig}(s, w)) = 1] = 1.
\end{equation}

Na Figura \ref{fig:2}, é possível visualizar um diagrama do comportamento de
um esquema de assinatura digital genérico. Note que $\sigma$ geralmente é
composto da concatenação da mensagem original com a assinatura do resumo
criptográfico desta, embora a saída do algoritmo \textsc{Sig} consista apenas
da aplicação de uma função interna a este ao resumo.

\section{O esquema Winternitz}

O esquema de assinatura digital única Winternitz(\textsc{Wots} --- \emph{Winternitz one-time signature}), em sua proposta original \cite{Merkle:1989:CDS:118209.118230},
apresenta versatilidade em relação ao tamanho de chaves e da assinatura, e também pode
ser configurado para utilizar diferentes funções de resumo criptográfico a fim de
utilizar recursos possivelmente disponíveis no dispositivo alvo.

Descreve-se abaixo o funcionamento do esquema e discute-se algumas de suas
características. Tome um parâmetro de segurança $m$, geralmente considerado como
o tamanho da saída da função de resumo criptográfico escolhido, e um parâmetro $w$
    \item Assumimos um parâmetro de segurança $m$, geralmente com o tamanho da saida de uma função de resumo cryptografico e escolhemos um parâmetro $w \in \mathbb{N}, w > 1$. Considerando a função *(non-compressing one-way)* $f : \{0, 1\}^{m} \longrightarrow \{0, 1\}^{m}$ e a função de resumo criptográfico $\mathcal{H} : \{0, 1\}^{*} \longrightarrow \{0, 1\}^{m}$.
    E, realizamos:
    $$t_1 = \left\lceil \frac{m}{w} \right\rceil, \quad t_2 = \left\lceil 
    \frac{\left\lfloor \log_2 t_1 \right\rfloor + 1 + w}{w} \right\rceil,
    \quad t = t_1 + t_2.$$
Estes parâmetros são escolhidos tal que $w$ seja o numero de bits a serem assinados simultaneamente, eles também estão diretamente relacionados ao tamanho da chave e a *(performance)* da assinatura.

\begin{itemize}
    \item\emph{Key Generation.}
    Seja $X = (x_{t-1}, \dots, x_0) \stackrel{\$}{\longleftarrow} \{0,1\}^m$ a chave privada, informalmente uma $t$-tupla de inteiros pseudo-aleatórios. A chave pubilca $Y = (y_{t-1}, \dots, y_0)$ pode ser derivada de $X$ aplicando-se $f$ para cada $x_i$ elementos $2^{w}-1$ vezes. Logo, $Y = (f^{2^{w}-1}(x_{t-1}), \dots, f^{2^{w}-1}(x_0))$.

    \item\emph{Signature Generation.}
    Pegando a mensagem $M$ e calculando o seu resumo $d = \mathcal{H}(M)$. Por conveniência, nós escolhemos $m$ ou $w$ para que $w \mid m$. Podem ser concatenados zeros ao resumo para que isso seja satisfeito. $d$ é dividido $t_1$-tupla de palavras base-$w$, $\mathcal{B}_1 = (b_{t-1}, \dots, b_{t-t_1})$. 
    Adicionalmente, calculamos o checksum usando a representação inteira dos elementos de $\mathcal{B}_1$:
    $$ c = \sum_{i=t-t_1}^{t-1} 2^w - 1 - b_i.$$
    Novamente, $c$ pode ser arredondado com zeros até que $w \mid \vert c \vert$. Finalmente, ele é dividido em uma $t_2$-tupla de palavras base-$w$, $\mathcal{B}_2 = (b_{t_2-1}, \dots, b_0)$. Com a realização de $\mathcal{B} = \mathcal{B}_1 \cup \mathcal{B}_2$ obtemos a assinatura:
    $$\alpha = (f^{b_{t-1}}(x_{t-1}), \dots, f^{b_0}(x_0)).$$
    \item\emph{Signature Verification.} 
    Para se assegurar a corretuda da assinatura $\alpha$, cada um de seu blocos $\alpha_i$ precisa ser verificado separadamente através do calculo das aplicações restantes de $f$. A assinatura é verificada corretamente se $$Y = (f^{2^w - 1 - b_{t-1}}(\alpha_{t-1}), \dots, f^{2^w - 1 - b_0}(\alpha_0)).$$

\end{itemize}

% In its original proposal~\cite{Merkle:1989:CDS:118209.118230}, the Winternitz
% one-time signature scheme (\textsc{Wots}) works as follows. Take $m$
% as a security parameter, usually the output size in bits of a
% cryptographic hash function, and choose a parameter
% $w \in \mathbb{N}, w > 1$. In addition, consider a non-compressing
% one-way function $f : \{0, 1\}^{m} \longrightarrow \{0, 1\}^{m}$
% and a cryptographic hash function
% $\mathcal{H} : \{0, 1\}^{*} \longrightarrow \{0, 1\}^{m}$.
% Then, compute
% $$t_1 = \left\lceil \frac{m}{w} \right\rceil, \quad t_2 = \left\lceil 
% \frac{\left\lfloor \log_2 t_1 \right\rfloor + 1 + w}{w} \right\rceil,
% \quad t = t_1 + t_2.$$
%
% These parameters are selected so that $w$ is the number of bits to be
% signed simultaneously. They are also directly related to the key size
% and signature performance, as we will see in the following.
%
% \emph{Key Generation.}
% Let $X = (x_{t-1}, \dots, x_0) \stackrel{\$}{\longleftarrow} \{0,1\}^m$
% be the private key, informally a $t$-tuple of pseudo-random integers.
% The public key $Y = (y_{t-1}, \dots, y_0)$ can be derived from $X$
% by applying $f$ to each of the $x_i$ elements $2^{w}-1$ times.
% Hence, $Y = (f^{2^{w}-1}(x_{t-1}), \dots, f^{2^{w}-1}(x_0))$.
%
% \emph{Signature Generation.} Take a message $M$ and compute its
% digest $d = \mathcal{H}(M)$. For convenience, we choose $m$ or $w$
% such that $w \mid m$. However, one may pad the digest
% by appending zeros to satisfy this requirement. $d$ is then split
% into a $t_1$-tuple of base-$w$ words
% $\mathcal{B}_1 = (b_{t-1}, \dots, b_{t-t_1})$.
% Additionally, we compute the checksum using the integer
% representation of the elements in $\mathcal{B}_1$:
% $$ c = \sum_{i=t-t_1}^{t-1} 2^w - 1 - b_i.$$
% Again, $c$ may be padded with zeroes until $w \mid \vert c \vert$.
% Finally, it is split into a $t_2$-tuple of base-$w$ words
% $\mathcal{B}_2 = (b_{t_2-1}, \dots, b_0)$.
% With $\mathcal{B} = \mathcal{B}_1 \cup \mathcal{B}_2$ computed,
% we obtain the signature
% $$\alpha = (f^{b_{t-1}}(x_{t-1}), \dots, f^{b_0}(x_0)).$$
%
% \emph{Signature Verification.} To ascertain the correctness of the
% signature $\alpha$, each of its blocks $\alpha_i$ need to be verified
% separately by computing the remaining applications of $f$.
% The signature verifies correctly if
% $$Y = (f^{2^w - 1 - b_{t-1}}(\alpha_{t-1}), \dots, f^{2^w - 1 - b_0}(\alpha_0)).$$

\subsection{\textsc{Wots+}}

\subsection{Esquemas baseados em árvores de Merkle}

% * como plugar o AES nele
% * esquemas posteriores

\bibliographystyle{alpha}
\bibliography{report} 

\end{document}