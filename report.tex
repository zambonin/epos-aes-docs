\documentclass{article}

\usepackage[a4paper, margin=3cm]{geometry}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[portuguese, onelanguage]{algorithm2e}
\usepackage{amsmath, amsfonts, enumitem, tikz, parskip, url}

\newcommand{\hh}{$\mathcal{H}$}
\newcommand{\hash}[2][]{\mathcal{H}^{#1}(#2)}
\newcommand{\binwds}[1]{\{0, 1\}^{#1}}

\title{Esquemas de assinatura digital pós-quânticos \\ baseados em AES}
\author{Gustavo Zambonin \\ \texttt{gustavo.zambonin@grad.ufsc.br} \and Marcello da Silva Klingelfus Junior \\ \texttt{marcello.klingelfus@grad.ufsc.br}}
\date{}

\begin{document}

\maketitle

\section{Introdução}

A aplicação de protocolos criptográficos é essencial no contexto da validação e
proteção de quaisquer comunicações realizadas por um conjunto de entidades,
sejam estas dispositivos eletrônicos ou indivíduos, em virtude da possível
criticalidade e sensibilidade atribuídas aos dados transmitidos. Esquemas de
assinatura digital são comumente utilizados para assegurar este processo de
maneira formal \cite{Goldreich:2004:FCV:975541}, através da autenticidade e
não-repúdio do remetente e certeza da integridade dos dados, a fim de
traduzir o resguardo provido por uma assinatura de próprio punho no mundo real.

Na prática, a maior parte destes esquemas utilizam como alicerce algorítmico
criptossistemas assimétricos baseados em problemas `'difíceis`' da teoria
dos números, como a fatoração de inteiros ou resolução do logaritmo discreto,
ambos para números grandes. Este fato provê a segurança necessária para os
esquemas em computadores clássicos (eletrônicos), por conta da inexistência de
algoritmos que resolvem estes problemas em tempo polinomial, até o momento.
Entretanto, em computadores quânticos, algoritmos dessa forma já existem - em
especial, o algoritmo de Shor \cite{Shor:1997:PAP:264393.264406} - efetivamente
tornando estes esquemas clássicos inseguros neste novo contexto.

Para combater esta situação, a criptografia pós-quântica encarrega-se de buscar
algoritmos criptográficos cuja segurança é considerada suficiente mesmo
utilizando-se de um computador quântico e ataques especializados, como o
algoritmo de Grover \cite{Grover:1996:FQM:237814.237866}. Esta área conta com
diversas abordagens diferentes: a criptografia baseada em reticulados,
polinômios multivariados sobre um corpo finito, códigos de correção de erros,
morfismos entre curvas elípticas supersingulares, criptossistemas simétricos.
e funções de resumo criptográfico. Em especial, é possível mesclar as duas
últimas opções a fim de aproveitar, respectivamente, o desempenho e a
simplicidade destas, bem como demonstrar a versatilidade garantida pelas
diferentes funções que podem ser utilizadas para a criação destes esquemas.

\section{Funções de resumo criptográfico}

Uma função de resumo \hh{} mapeia valores deterministicamente entre dois
conjuntos. O domínio pode ter tamanho infinito, e neste caso a função pode ser
chamada de função de compressão; a imagem deve ser estritamente menor do que o
domínio e finita, e elementos deste conjunto são chamados de resumos. É
desejável para \hh{} que estes mapeamentos ocorram de tal maneira que não
ocorra uma relação aparente entre entradas e saídas da função. Funções de
resumo adicionadas de propriedades que tornam-as adequadas para utilização no
contexto de segurança da informação são chamadas de funções de resumo
criptográfico, e possibilitam a certeza da integridade de dados, mesmo que
armazenados em um dispositivo inseguro.

Tome $X : \binwds{*}$ e $Y : \binwds{n}$, $n \in \mathbb{N}$. Então,
$\mathcal{H} : X \longrightarrow Y$. De acordo com
\cite{stinson2005cryptography}, para que qualquer \hh{} seja considerada
criptográfica, deve ser difícil resolver os três problemas listados abaixo.
É importante notar que um problema é considerado `'difícil`', ou
computacionalmente impraticável, quando o tempo ou recursos gastos para esta
computação excedem a validade ou utilidade da informação desejada.

\begin{enumerate}[label=\roman*.]

  \item Fornecido um resumo $h \in Y$, achar a mensagem original $m \in X$ que
    gerou $h$ através de $\hash{m} = h$; \hh{} é considerada resistente à
    pré-imagem (\textsc{Pre}) se isto não pode ser resolvido de maneira
    eficiente.

  \item Fornecida uma mensagem $m_0 \in X$, achar uma mensagem $m_1 \in X$ tal
    que $m_0 \neq m_1$ e $\hash{m_0} = \hash{m_1}$. \hh{} é considerada
    resistente à segunda pré-imagem (\textsc{Sec}) se isto não pode ser
    resolvido de maneira eficiente.

  \item Para quaisquer duas mensagens $m_0, \; m_1 \in X$ e $m_0 \neq m_1$,
    $\hash{m_0} = \hash{m_1}$. \hh{} é considerada resistente à colisões
    (\textsc{Col}) se isto não pode ser resolvido de maneira eficiente.

\end{enumerate}

\section{Criptografia simétrica}

Algoritmos criptográficos que utilizam a mesma chave para criptografar o
texto plano e descriptografar o texto correspondente cifrado são classificados
como algoritmos de criptografia simétrica. A chave representa um segredo
compartilhado entre entidades em uma comunicação segura. Porém, a necessidade
de um canal seguro para o estabelecimento desta chave apresenta-se como uma
desvantagem deste tipo de criptografia. Geralmente, cifras de bloco (DES, AES)
ou de fluxo (RC4, Salsa20) são a base para estes algoritmos. Utilizando estas
como alicerce, é possível construir funções de resumo criptográfico: por
exemplo, a construção Merkle-Damgård, base para as funções MD5, SHA1 e SHA2,
utiliza uma função de compressão única, obtida a partir de uma cifra de bloco.

\subsection{AES --- \emph{Advanced Encryption Standard}}

O AES é uma cifra de blocos que opera, a partir de uma chave $K$ de tamanho $n = \{128, 192, 256\}$, sobre uma matriz de estado $A$ de dimensões $4 \times 4$, onde $A_{i,j} \in \mathbb{F}_{2^{8}}$\footnote{Definido pelo polinômio irredutível $m(x) = x^{8} + x^{4} + x^{3} + x + 1$. Adições e multiplicações em corpos da forma $\mathbb{F}_{2^n}$ são, respectivamente, representadas por operações \texttt{AND} e \texttt{XOR}, e coeficientes de polinômios podem ser apenas $0$ ou $1$, tornando esta estrutura convidativa para operações computacionais.}, $0 \leq i, j < 3$. Seu funcionamento é denominado iterativo, consistindo em aplicações sequenciais de quatro operações ordenadas (\textsc{SubBytes}, \textsc{ShiftRows}, \textsc{MixColumns} e \textsc{AddRoundKey}) sobre $A$. A quantidade destas aplicações, denominadas rodadas ($n_r$), depende diretamente do tamanho da chave: $n = 128 \rightarrow n_r = 10, n = 192 \rightarrow n_r = 12, n = 256 \rightarrow n_r = 14$.

Note que existe uma rodada adicional introdutória composta apenas de \textsc{AddRoundKey},
para que o estado inicial seja modificado. Ademais, \textsc{MixColumns} é ignorado na última rodada, a fim de facilitar a reversibilidade da cifra. Uma rotina de expansão de chave existe para que $K$ seja propagada em todas as rodadas com valores derivados, porém distintos. Estes componentes serão descritos abaixo.

\begin{enumerate}[label=\roman*.]

    \item \textsc{SubBytes}: realiza-se a reposição de $A_{i,j}$
        pelo seu valor correspondente em uma \emph{substitution-box} (\emph{S-box}, construída a partir de uma transformação afim em $A_{i,j}^{-1}$ sobre $\mathbb{F}_2$), onde os \emph{nibbles} mais e menos significativos, respectivamente, representam a linha e a coluna do elemento na \emph{S-box}.

    \item \textsc{ShiftRows}: cada linha de $A$, $A_i$,
        é deslocada circularmente à esquerda $i$ vezes.

    \item \textsc{MixColumns}: cada coluna de $A$, $A_j$, é multiplicada pelo polinômio
        $c = 03 \cdot x^{3} + 01 \cdot x^{2} + 01 \cdot x + 02$, módulo $x^{4} + 1$, para que o resultado ainda seja um polinômio de grau máximo 3, apto a ser representado na coluna.

    \item \textsc{AddRoundKey}: a operação \texttt{XOR} bit a bit é aplicada entre $A$ e o
        bloco da chave referente à rodada.

\end{enumerate}

A expansão de chaves \textsc{KeyExpansion} consiste da criação de um conjunto de palavras $K_e$ de 32 bits.
Tome $\ell = \frac{n}{32}$, e assumindo que é necessário criar palavras suficientes para utilização em todas as rodadas do algoritmo, então $t = \ell(n_r + 1)$ e $K^e = \{k_0, \dots, k_{t - 1}\}$. Também defina $rot(x)$ como o deslocamento circular à esquerda de 8 bits da palavra $x$, e a lista de constantes $RC$ com elementos em $\mathbb{F}_{2^{8}}$ definida pela recursão $RC_0 = x^0, RC_1 = x^1, RC_j = x^{j-1} \cdot RC_{j-1}, j > 2$. Inicialmente, $\{k_0, \dots, k_{\ell - 1}\} = K$, e $\forall i \geq \ell, K^{e}_{i} = K^{e}_{i - \ell} \oplus \mathbf{k}$. A palavra $\mathbf{k}$ é decidida de acordo com as restrições (mutualmente exclusivas) abaixo.

\begin{itemize}
    \item $i \equiv 0 \pmod{4} \rightarrow \mathbf{k}
        = \textsc{SubBytes}(rot(K^{e}_{i - 1})) \oplus RC_{\frac{i}{\ell}}$;
    \item $\ell = 8 \land i \equiv 4 \pmod{8} \rightarrow \mathbf{k}
        = \textsc{SubBytes}(K^{e}_{i - 1})$.
\end{itemize}

Assim, uma função que criptografa uma mensagem $m$ e retorna um texto cifrado $c$ pode ser
representada pelo pseudocódigo abaixo.

\begin{algorithm}[H]
    \KwData{$m$, o texto a ser cifrado; $K$, a chave desejada}
    \KwResult{$c$, o texto cifrado resultante}

    $A \longleftarrow m$\;
    $K^{e}_{0} \dots K^{e}_{(n_r + 1) \cdot \ell}
        \longleftarrow \textsc{KeyExpansion}(K)$\;
    $A \longleftarrow \textsc{AddRoundKey}(A,
        \{K^{e}_{0}, \dots, K^{e}_{\ell - 1}\})$\;
    
    \For{$i \leftarrow 1$ \KwTo $n_r - 1$}{
        $A \longleftarrow \textsc{SubBytes}(A)$\;
        $A \longleftarrow \textsc{ShiftRows}(A)$\;
        $A \longleftarrow \textsc{MixColumns}(A)$\;
        $A \longleftarrow \textsc{AddRoundKey}(A,
            \{K^{e}_{i \cdot \ell}, \dots, K^{e}_{(i + 1) \cdot \ell}\})$\;
    }
 
    $A \longleftarrow \textsc{SubBytes}(A)$\;
    $A \longleftarrow \textsc{ShiftRows}(A)$\;
    $A \longleftarrow \textsc{AddRoundKey}(A,
        \{K^{e}_{n_r \cdot \ell}, \dots, K^{e}_{(n_r + 1) \cdot (\ell - 1)}\})$\;

    $c \longleftarrow A$\;
\end{algorithm}

Para que a cifra seja caracterizada como simétrica, é preciso criar uma função que faça o inverso do procedimento acima. Assim, suas etapas precisam ser modificadas de acordo.

\begin{enumerate}[label=\roman*.]

    \item \textsc{InvShiftRows}: cada linha de $A$, $A_i$, é deslocada circularmente à direita $i$ vezes.

    \item \textsc{InvSubBytes}: é necessário computar a transformação afim inversa para cada elemento $A_{i,j}$, e depois calcular sua inversa multiplicativa.
    
    \item \textsc{InvMixColumns}: cada coluna de $A$, $A_j$, é multiplicada pela inversa multiplicativa $d = c^{-1}$, obtida por: $(03 \cdot x^{3} + 01 \cdot x^{2} + 01 \cdot x + 02) \cdot d \equiv 1 \pmod{x^{4} + 1}$, logo $d(x) = 0B \cdot x^{3} + OD \cdot x^{2} + 09 \cdot x + 0E$.

\end{enumerate}

Por fim, o algoritmo resultante pode ser representado pelo pseudocódigo abaixo. Note a mudança da ordem das etapas, e a utilização invertida de $K_e$.

\begin{algorithm}[H]
    \KwData{$c$, o texto cifrado; $K$, a chave desejada}
    \KwResult{$m$, o texto claro resultante}

    $A \longleftarrow c$\;
    $K^{e}_{0} \dots K^{e}_{(n_r + 1) \cdot \ell}
        \longleftarrow \textsc{KeyExpansion}(K)$\;
    $A \longleftarrow \textsc{AddRoundKey}(A,
        \{K^{e}_{0}, \dots, K^{e}_{\ell - 1}\})$\;
    
    \For{$i \leftarrow n_r - 1$ \KwTo $1$}{
        $A \longleftarrow \textsc{InvShiftRows}(A)$\;
        $A \longleftarrow \textsc{InvSubBytes}(A)$\;
        $A \longleftarrow \textsc{AddRoundKey}(A,
            \{K^{e}_{i \cdot \ell}, \dots, K^{e}_{(i + 1) \cdot \ell}\})$\;
        $A \longleftarrow \textsc{InvMixColumns}(A)$\;
    }
 
    $A \longleftarrow \textsc{InvShiftRows}(A)$\;
    $A \longleftarrow \textsc{InvSubBytes}(A)$\;
    $A \longleftarrow \textsc{AddRoundKey}(A,
        \{K^{e}_{0}, \dots, K^{e}_{\ell - 1}\})$\;

    $m \longleftarrow A$\;
\end{algorithm}

\section*{Criptografia assimétrica}

\section*{Esquemas de assinatura digital}

\section*{O esquema Winternitz}
% * como plugar o AES nele
% * esquemas posteriores

\bibliographystyle{alpha}
\bibliography{report} 

\end{document}