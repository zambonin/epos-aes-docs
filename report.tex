\documentclass{article}

\usepackage[a4paper, margin=3cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{parskip}
\usepackage{url}
\usepackage{amsfonts}
\usepackage{amsmath, amsfonts, enumitem, tikz, parskip}

\newcommand{\hh}{$\mathcal{H}$}

\title{Esquemas de assinatura digital pós-quânticos \\ baseados em AES}
\author{Gustavo Zambonin \\ \texttt{gustavo.zambonin@grad.ufsc.br} \and Marcello da Silva Klingelfus Junior \\ \texttt{marcello.klingelfus@grad.ufsc.br}}
\date{}

\begin{document}

\maketitle

\section{Introdução}

A aplicação de protocolos criptográficos é essencial no contexto da validação e
proteção de quaisquer comunicações realizadas por um conjunto de entidades,
sejam estas dispositivos eletrônicos ou indivíduos, em virtude da possível
criticalidade e sensibilidade atribuídas aos dados transmitidos. Esquemas de
assinatura digital são comumente utilizados para assegurar este processo de
maneira formal \cite{Goldreich:2004:FCV:975541}, através da autenticidade e
não-repúdio do remetente e certeza da integridade dos dados, a fim de
traduzir o resguardo provido por uma assinatura de próprio punho no mundo real.

Na prática, a maior parte destes esquemas utilizam como alicerce algorítmico
criptossistemas assimétricos baseados em problemas `'difíceis`' da teoria
dos números, como a fatoração de inteiros ou resolução do logaritmo discreto,
ambos para números grandes. Este fato provê a segurança necessária para os
esquemas em computadores clássicos (eletrônicos), por conta da inexistência de
algoritmos que resolvem estes problemas em tempo polinomial, até o momento.
Entretanto, em computadores quânticos, algoritmos dessa forma já existem - em
especial, o algoritmo de Shor \cite{Shor:1997:PAP:264393.264406} - efetivamente
tornando estes esquemas clássicos inseguros neste novo contexto.

Para combater esta situação, a criptografia pós-quântica encarrega-se de buscar
algoritmos criptográficos cuja segurança é considerada suficiente mesmo
utilizando-se de um computador quântico e ataques especializados, como o
algoritmo de Grover \cite{Grover:1996:FQM:237814.237866}. Esta área conta com
diversas abordagens diferentes: a criptografia baseada em reticulados,
polinômios multivariados sobre um corpo finito, códigos de correção de erros,
morfismos entre curvas elípticas supersingulares, criptossistemas simétricos.
e funções de resumo criptográfico. Em especial, é possível mesclar as duas
últimas opções a fim de aproveitar, respectivamente, o desempenho e a
simplicidade destas, bem como demonstrar a versatilidade garantida pelas
diferentes funções que podem ser utilizadas para a criação destes esquemas.

\section{Funções de resumo criptográfico}

Uma função de resumo \hh{} mapeia valores deterministicamente entre dois
conjuntos. O domínio pode ter tamanho infinito, e neste caso a função pode ser
chamada de função de compressão; a imagem deve ser estritamente menor do que o
domínio e finita, e elementos deste conjunto são chamados de resumos. É
desejável para \hh{} que estes mapeamentos ocorram de tal maneira que não
ocorra uma relação aparente entre entradas e saídas da função. Funções de
resumo adicionadas de propriedades que tornam-as adequadas para utilização no
contexto de segurança da informação são chamadas de funções de resumo
criptográfico, e possibilitam a certeza da integridade de dados, mesmo que
armazenados em um dispositivo inseguro.

Tome $X : \binwds{*}$ e $Y : \binwds{n}$, $n \in \mathbb{N}$. Então,
$\mathcal{H} : X \longrightarrow Y$. De acordo com
\cite{stinson2005cryptography}, para que qualquer \hh{} seja considerada
criptográfica, deve ser difícil resolver os três problemas listados abaixo.
É importante notar que um problema é considerado `'difícil`', ou
computacionalmente impraticável, quando o tempo ou recursos gastos para esta
computação excedem a validade ou utilidade da informação desejada.

\begin{enumerate}[label=\roman*.]

  \item Fornecido um resumo $h \in Y$, achar a mensagem original $m \in X$ que
    gerou $h$ através de $\hash{m} = h$; \hh{} é considerada resistente à
    pré-imagem (\textsc{Pre}) se isto não pode ser resolvido de maneira
    eficiente.

  \item Fornecida uma mensagem $m_0 \in X$, achar uma mensagem $m_1 \in X$ tal
    que $m_0 \neq m_1$ e $\hash{m_0} = \hash{m_1}$. \hh{} é considerada
    resistente à segunda pré-imagem (\textsc{Sec}) se isto não pode ser
    resolvido de maneira eficiente.

  \item Para quaisquer duas mensagens $m_0, \; m_1 \in X$ e $m_0 \neq m_1$,
    $\hash{m_0} = \hash{m_1}$. \hh{} é considerada resistente à colisões
    (\textsc{Col}) se isto não pode ser resolvido de maneira eficiente.

\end{enumerate}

\section{Criptografia simétrica}

Algoritmos criptográficos que utilizam a mesma chave para criptografar o
texto plano e descriptografar o texto correspondente cifrado são classificados
como algoritmos de criptografia simétrica. A chave representa um segredo
compartilhado entre entidades em uma comunicação segura. Porém, a necessidade
de um canal seguro para o estabelecimento desta chave apresenta-se como uma
desvantagem deste tipo de criptografia. Geralmente, cifras de bloco (DES, AES)
ou de fluxo (RC4, Salsa20) são a base para estes algoritmos. Utilizando estas
como alicerce, é possível construir funções de resumo criptográfico: por
exemplo, a construção Merkle-Damgård, base para as funções MD5, SHA1 e SHA2,
utiliza uma função de compressão única, obtida a partir de uma cifra de bloco.

\subsection{AES --- \emph{Advanced Encryption Standard}}

O AES é um algoritmo cryptografico(???) simétrica de blocos, ou seja o numero de bytes cifrados a cada para uma chave é fixo em 16bytes, e faz as suas operações de adição, multiplicação e divisão sobre um corpo finito $\mathbb{F}_{2^{8}}$ em relação a um polinomio irredutivel m, onde $m(x) = x^{8} + x^{4} + x^{3} + x + 1$. 
A sua cifra á feita através da repetição de determinado passos do seu algoritmo multiplas vezes, os quais chamamos de 'rodada', o numero de rodadas varia em relação ao tamanho da chave, 16bytes->10 rodadas, 24bytes->12 rodadas, 32bytes->14 rodadas. *do your magic*


As operações realizadas por ele, em ordem, são:

\begin{itemize}

\item Derivar as chaves de cada rodada a partir da chave inicial: O algoritmo é copia a chave inicial para as primeiras posições da chave expandida. Cada 4bytes inseridos dependem dos 4bytes imediatamente anterior e dos bytes inseridos 4 posições atrás. Caso a posição/4 = i e $i \pmod{n} != 0$, onde n = 4 para k = 16bytes,6 para k = 24bytes e 8 para k = 32bytes), os 8bytes são gerados com um simples XOR entre as os bytes da qual eles dependem, caso contrario eles são gerados através da função RotWord-> SubWord -> Rcon. A subfunção RotWord a qual faz uma troca de bytes na, onde o byte da primeira posição é colocado na última posição e os bytes das outras posições são deslocados à esquerda. A subfunção SubWord substitui cada byte pelo valor respectivo na caixa S-Box. Rcon é um byte constante que tem os três bits mais à direita com valor zerado e o byte mais à esquerda é definido pela multiplicação no corpo finito.

\item 


\end{itemize}
-O processo de cifra é feito, ordenadamente, através de: 
XOR bit a bit entre a chave e a mensagem
Substituição de sucessões (Nibble Substituition) com caixas S
Deslocamento Circular
Embaralhamento das Colunas
XOR bit a bit entre a chave expandida e a mensagem
Substituição de sucessões com caixas S
Deslocamento Circular
XOR bit a bit entre a chave expandida e a mensagem


\section*{Criptografia assimétrica}

\section*{Esquemas de assinatura digital}

\section*{O esquema Winternitz}
% * como plugar o AES nele
% * esquemas posteriores

\bibliographystyle{alpha}
\bibliography{report} 

\end{document}